# Техническое видение: Страница утилит (Utils Page)

## 1. Технологии

**Backend:**
- Java + Spring Boot (используем существующую инфраструктуру проекта)
- Spring Web для REST API
- Apache Commons CSV для работы с CSV
- Apache POI для Excel файлов

**Frontend:**
- Thymeleaf для простых HTML форм
- Bootstrap для базовой стилизации
- Минимум JavaScript

**Хранение данных:**
- Временные файлы на диске
- Без использования БД для утилит
- Результаты отдаются напрямую пользователю

**Ограничения:**
- Размер файлов: до 1200MB (как в текущих настройках проекта)
- Открытый доступ без авторизации
- Обработка только загруженных файлов

## 2. Принципы разработки

**KISS (Keep It Simple, Stupid):**
- Одна утилита = одна страница + один контроллер
- Никаких сложных паттернов проектирования
- Прямолинейная логика без абстракций
- Копирование кода между утилитами (утилиты слишком разные по логике)

**Быстрая разработка:**
- Простое добавление новых утилит через шаблонирование
- Минимум зависимостей
- Stateless обработка (загрузил → обработал → скачал)

**Надежность:**
- Стандартная валидация как в основном проекте
- Обработка ошибок с понятными сообщениями
- Гибкие timeout'ы в зависимости от типа утилиты и размера файла

**Масштабируемость:**
- Каждая утилита независима
- Простой механизм добавления новых утилит
- Возможность настройки параметров для каждой утилиты отдельно

## 3. Структура проекта

**Интеграция в существующий проект:**
```
src/main/java/com/java/
├── controller/utils/              # Новая папка
│   ├── UtilsController.java       # Главная страница со списком утилит
│   ├── BarcodeMatchController.java
│   ├── UrlCleanerController.java
│   └── LinkExtractorController.java
├── service/utils/                 # Новая папка  
│   ├── BarcodeMatchService.java   # Бизнес-логика утилит
│   ├── UrlCleanerService.java
│   └── LinkExtractorService.java
└── (переиспользуем существующие сервисы)
    ├── service/file/FileAnalyzerService    # Анализ файлов
    ├── util/ControllerUtils                # Общие операции
    ├── model/entity/ImportTemplateField    # Система полей
    └── service/imports/validation/TemplateValidationService
```

**Frontend структура:**
```
src/main/resources/
├── templates/utils/               # Новая папка
│   ├── utils-main.html           # Главная страница со списком
│   ├── barcode-match.html
│   ├── url-cleaner.html
│   └── link-extractor.html
└── static/utils/                  # При необходимости
```

**Принципы структуры:**
- Каждый контроллер полностью независим
- Максимальное переиспользование существующих сервисов
- Отдельная главная страница со списком всех утилит
- Простое добавление новых утилит через копирование шаблона

## 4. Архитектура проекта

**Архитектурные слои:**
```
Presentation Layer (Thymeleaf + простой спиннер)
    ↓
Controller Layer (utils/*)  
    ↓
Service Layer (utils/* + переиспользование существующих)
    ↓  
File System (временные файлы)
```

**Поток обработки:**
1. **Загрузка файла** → FileAnalyzerService (валидация + анализ структуры)
2. **Выбор полей** → система ImportTemplateField (без сохранения в БД)
3. **Обработка данных** → утилита-сервис (с настраиваемым timeout)
4. **Результат** → прямая отдача файла пользователю для скачивания

**Архитектурные принципы:**
- **Stateless операции** - без состояния между запросами
- **Прямая отдача результатов** - без промежуточного хранения
- **Переиспользование инфраструктуры** - максимальное использование существующих сервисов
- **Минимум логирования** - только критичные ошибки
- **Простой UI** - спиннер вместо прогресс-бара
- **Настраиваемые timeout'ы** - для разных типов утилит

**Взаимодействие с существующей системой:**
- Используем FileAnalyzerService для работы с файлами
- Применяем систему полей ImportTemplateField для маппинга
- Переиспользуем ControllerUtils для общих операций
- Timeout настраивается через application.properties

## 5. Модель данных

**Принцип "Без БД для утилит":**
- Все операции в памяти и временных файлах
- Только DTO для передачи данных между слоями
- Максимальное переиспользование существующих моделей

**DTO структура:**
```java
// Общие DTO
UtilFileUploadDto - загрузка и валидация файла
UtilResultDto - результат обработки с метаданными

// Специфичные DTO для каждой утилиты
BarcodeMatchDto - настройки сопоставления штрихкодов  
UrlCleanerDto - параметры очистки URL
LinkExtractorDto - выбор колонок для извлечения ссылок
RedirectCollectorDto - настройки сбора редиректов
```

**Переиспользование существующих моделей:**
- **FileMetadata** - результат анализа файла
- **ImportTemplateField** - логика работы с полями файла (без сохранения в БД)
- **Validation аннотации** - из существующих DTO проекта

**Хранение состояния:**
- Настройки утилит сохраняются в HTTP сессии
- Временные файлы в file system
- Результаты обработки отдаются сразу без сохранения

**Жизненный цикл данных:**
1. Загрузка файла → временное сохранение + анализ → FileMetadata
2. Настройка утилиты → сохранение в сессии → UtilConfigDto
3. Обработка → UtilResultDto → прямая отдача пользователю
4. Очистка сессии и временных файлов

## 6. Работа

**Пользовательский workflow:**
```
Главная страница (/utils) 
    ↓ выбор утилиты
Страница утилиты (/utils/{util-name})
    ↓ загрузка файла(ов)
Анализ файла + выбор параметров
    ↓ запуск обработки  
Спиннер + ожидание результата
    ↓ завершение
Прямое скачивание файла
```

**Принципы работы:**
- **"Только заново"** - нет возможности вернуться к предыдущему шагу
- **Без превью** - результат сразу отдается на скачивание  
- **Линейный процесс** - один шаг за другим без сохранения промежуточных состояний
- **Простота навигации** - каждый шаг = отдельная страница

**Ограничения и очередность:**
- Используем существующие async настройки проекта:
  - core-pool-size: 1-2 потока для утилит
  - max-pool-size: 2-4 потока (зависит от профиля)
  - Встроенная система очередей Spring ThreadPoolExecutor
- Если превышен лимит → сообщение "попробуйте позже"

**Примеры workflow по утилитам:**
1. **Сопоставление штрихкодов**: загрузка 2 файлов → выбор колонок → обработка → результат
2. **Очистка URL**: загрузка файла → выбор колонки с ссылками → настройки очистки → результат  
3. **Сбор ссылок с ID**: загрузка файла → выбор ID колонки + колонок со ссылками → результат

**Обработка ошибок:**
- Валидация на каждом шаге
- Понятные сообщения об ошибках
- При ошибке = начать заново

## 7. Мониторинг

**Принцип "Минимум мониторинга":**
- Без детального логирования операций
- Без сохранения истории операций
- Только критичные ошибки и базовые метрики

**Мониторинг через стандартные Spring инструменты:**
- **Thread pool monitoring** - через существующие async настройки
- **Стандартное Spring логирование** - только ERROR уровень для утилит
- **Spring Actuator endpoints** - встроенные метрики JVM и приложения

**Дополнительные метрики:**
- **Счетчик операций** - простой AtomicLong в каждом сервисе утилит
  - Количество успешных операций
  - Количество ошибок
  - Отображение на главной странице утилит (опционально)

**Что НЕ мониторим:**
- Детальные логи операций (принцип KISS)
- Дисковое пространство (общий мониторинг проекта)
- Персональную статистику пользователей
- История выполненных операций

**Обработка критичных ошибок:**
- IOException, OutOfMemoryError, TimeoutException
- Логирование в стандартный Spring logger
- Graceful degradation при превышении лимитов

**Переиспользование инфраструктуры:**
- Существующая система логирования (logback)
- Настройки thread pool из application.properties
- Spring Boot стандартные health checks

## 8. Сценарии работы

**Сценарий 1: Сопоставление штрихкодов (в одном файле)**
1. `/utils/barcode-match` → загрузка одного файла
2. Выбор колонок:
   - Колонка с ID клиента (кому добавляем ссылки)
   - Колонка с искомыми штрихкодами (могут быть через запятую)
   - Колонка со штрихкодами для поиска (могут быть через запятую)  
   - Колонка со ссылками
3. Логика обработки:
   - Игнорировать все ненужные знаки в штрихкодах
   - Пропускать некорректные ШК (!=13 символов)
   - Обрабатывать несколько ШК через запятую в ячейке
4. Результат: файл с сопоставленными данными

**Сценарий 2: Очистка URL**  
1. `/utils/url-cleaner` → загрузка файла со ссылками
2. Выбор колонки с URL
3. Настройки очистки: убрать UTM, реферальные параметры, etc.
4. Обработка → файл с очищенными ссылками

**Сценарий 3: Сбор ссылок с привязкой к ID**
1. `/utils/link-extractor` → загрузка файла
2. Выбор колонки с ID
3. Обработка: итерация по всем столбцам в каждой строке, поиск всех URL
4. Результат: файл с парами "ID - найденная ссылка"

**Сценарий 4: Сбор финальных URL после редиректов**
1. `/utils/redirect-collector` → загрузка файла со ссылками
2. Выбор колонки с исходными URL
3. Настройки: максимальное количество редиректов, timeout для запросов
4. Обработка: переход по каждой ссылке, следование редиректам
5. Результат: файл с парами "исходная ссылка - финальная ссылка"

**Общие принципы сценариев:**
- Один файл на входе (кроме случаев где логически нужно несколько)
- Гибкий выбор колонок через интерфейс
- Умная обработка данных (игнорирование мусора, парсинг через запятую)
- Результат сразу на скачивание

## 9. Деплой

**Принцип "Без отдельного деплоя":**
- Утилиты как часть основного приложения
- Никаких дополнительных сервисов или контейнеров
- Тот же JAR файл, тот же порт, та же инфраструктура

**Интеграция в существующий процесс:**
1. **Сборка**: `mvn clean package` включает утилиты в общий JAR
2. **Запуск**: стандартный `java -jar` без изменений
3. **Доступ**: утилиты доступны по `/utils/*` URL
4. **Конфигурация**: те же `application.properties` и профили

**Настройки:**
- Переиспользуем существующие async настройки (thread pools)
- Те же профили: dev, prod, silent, verbose
- Никаких дополнительных конфигурационных параметров
- Timeout и размеры файлов из общих настроек проекта

**Интеграция в UI:**
- **Главное меню приложения** - добавить пункт "Утилиты"
- **Переход на `/utils`** - страница со списком всех доступных утилит
- **Навигация** - из утилит можно вернуться в главное меню

**Преимущества подхода:**
- Нет усложнения инфраструктуры
- Переиспользование всех существующих настроек
- Простота поддержки и обновления
- Единая точка входа для всего функционала

## 10. Подход к конфигурированию

**Принцип "Максимальное переиспользование":**
- Используем все существующие настройки проекта
- Новые параметры добавляем только при критической необходимости
- Простые значения по умолчанию в коде

**Переиспользуемые настройки:**
```properties
# Размеры файлов
spring.servlet.multipart.max-file-size=1200MB
spring.servlet.multipart.max-request-size=1200MB

# Thread pool для асинхронной обработки
import.async.core-pool-size=1
import.async.max-pool-size=2
import.async.queue-capacity=100

# Timeout и память
import.timeout-minutes=60
import.max-memory-percentage=60

# Директории для временных файлов
application.upload.dir=data/upload
application.temp.dir=data/temp
```

**Подход к новым настройкам:**
- **Сначала**: попробовать использовать существующие
- **Если невозможно**: добавить в `application.properties`
- **Формат**: `utils.{utility-name}.{parameter}`
- **Профили**: те же dev/prod/silent/verbose

**Принципы конфигурации:**
- Разумные значения по умолчанию в коде
- Минимум внешних параметров  
- Конфигурация только действительно важного
- Никаких отдельных конфигурационных классов

## 11. Подход к логгированию

**Принцип "Минимум логов":**
- Используем существующую систему логирования (logback)
- Только ERROR уровень для критичных ошибок
- Никаких DEBUG/INFO логов операций утилит

**Переиспользование логирования:**
```java
// В каждом сервисе утилит
@Slf4j
public class BarcodeMatchService {
    
    // Логируем только критичные ошибки
    log.error("Failed to process barcode matching for file: {}", fileName, ex);
    
    // НЕ логируем обычные операции
    // log.info("Processing barcode matching..."); - НЕ НУЖНО
}
```

**Что логируем:**
- IOException при работе с файлами
- OutOfMemoryError и другие критичные системные ошибки
- TimeoutException при превышении лимитов времени
- Неожиданные RuntimeException

**Что НЕ логируем:**
- Детали операций обработки файлов
- Пользовательские действия и выбор параметров
- Статистику и метрики выполнения
- Промежуточные результаты обработки

**Настройки логирования:**
- Существующий `logback-spring.xml` без изменений
- Тот же уровень логов что и основное приложение
- Никаких отдельных appender'ов для утилит
- Логи утилит в общем потоке приложения

---

# Заключение

Техническое видение для страницы утилит готово. Документ служит отправной точкой для разработки максимально простого решения по принципам KISS, с переиспользованием существующей инфраструктуры проекта и минимальными изменениями в архитектуре.
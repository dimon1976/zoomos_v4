package com.java.service.utils;

import com.java.config.AntiBlockConfig;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;
import reactor.netty.transport.ProxyProvider;

import java.net.URI;
import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Современная HTTP стратегия на базе Spring WebClient с Reactive подходом
 */
// @Service // Временно отключено из-за проблем с WebFlux
@RequiredArgsConstructor
@Slf4j
public class WebClientStrategy implements AntiBlockStrategy {
    
    private final AntiBlockConfig antiBlockConfig;
    private WebClient webClient;
    
    @Override
    public String getStrategyName() {
        return "WebClient";
    }
    
    @Override
    public int getPriority() {
        return 1; // Высокий приоритет, но после OkHttp
    }
    
    @Override
    public boolean isAvailable() {
        try {
            Class.forName("org.springframework.web.reactive.function.client.WebClient");
            Class.forName("reactor.netty.http.client.HttpClient");
            initializeWebClient();
            return true;
        } catch (ClassNotFoundException e) {
            if (antiBlockConfig.isLogStrategies()) {
                log.warn("WebClientStrategy недоступна: отсутствуют зависимости WebFlux - {}", e.getMessage());
            }
            return false;
        }
    }
    
    /**
     * Инициализация WebClient с настройками для обхода блокировок
     */
    private void initializeWebClient() {
        try {
            // Настраиваем HttpClient с расширенными возможностями
            HttpClient httpClient = HttpClient.create()
                .responseTimeout(Duration.ofSeconds(30))
                .followRedirect(false) // КРИТИЧНО: отключаем автоматические редиректы
                .compress(true)
                .keepAlive(true)
                .secure(sslSpec -> sslSpec
                    .handshakeTimeout(Duration.ofSeconds(10))
                );
            
            // Создаем WebClient с кастомным HttpClient
            this.webClient = WebClient.builder()
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .codecs(configurer -> configurer
                    .defaultCodecs()
                    .maxInMemorySize(1024 * 1024) // 1MB buffer
                )
                .build();
                
        } catch (Exception e) {
            log.warn("Ошибка инициализации WebClient: {}", e.getMessage());
            // Fallback на базовый WebClient
            this.webClient = WebClient.create();
        }
    }
    
    @Override
    public RedirectCollectorService.RedirectResult processUrl(String originalUrl, int maxRedirects, int timeoutSeconds) {
        if (webClient == null) {
            initializeWebClient();
        }
        
        RedirectCollectorService.RedirectResult result = new RedirectCollectorService.RedirectResult();
        result.setOriginalUrl(originalUrl);
        result.setRedirectCount(0);
        
        try {
            String currentUrl = originalUrl;
            int redirectCount = 0;
            long startTime = System.currentTimeMillis();
            
            while (redirectCount <= maxRedirects) {
                WebClient.RequestHeadersSpec<?> request = webClient
                    .get()
                    .uri(currentUrl);
                
                // Настраиваем реалистичные заголовки
                setupRealisticHeaders(request);
                
                try {
                    // Выполняем запрос с обработкой статуса
                    Mono<String> responseMono = request
                        .exchangeToMono(response -> {
                            HttpStatus status = (HttpStatus) response.statusCode();
                            int statusCode = status.value();
                            long elapsedTime = System.currentTimeMillis() - startTime;
                            
                            if (antiBlockConfig.isLogStrategies()) {
                                log.info("URL: {} | Strategy: WebClient | Status: {} | Time: {}ms", 
                                        currentUrl, statusCode, elapsedTime);
                            }
                            
                            // Возвращаем статус код и заголовки в виде строки для дальнейшего анализа
                            String locationHeader = response.headers().header("Location").stream()
                                    .findFirst().orElse(null);
                            
                            return Mono.just(statusCode + "|" + (locationHeader != null ? locationHeader : ""));
                        });
                    
                    // Ожидаем результат с таймаутом
                    String responseData = responseMono
                        .timeout(Duration.ofSeconds(timeoutSeconds))
                        .block();
                    
                    if (responseData == null) {
                        break;
                    }
                    
                    String[] parts = responseData.split("\\|", 2);
                    int statusCode = Integer.parseInt(parts[0]);
                    String location = parts.length > 1 && !parts[1].isEmpty() ? parts[1] : null;
                    
                    // 1. РЕДИРЕКТЫ - проверяем 3xx статусы
                    if (isRedirectStatus(statusCode)) {
                        if (location != null && !location.isEmpty()) {
                            String resolvedUrl = resolveUrl(currentUrl, location);
                            redirectCount++;
                            
                            if (antiBlockConfig.isLogStrategies()) {
                                log.info("WebClient redirect [{}]: {} -> {}", redirectCount, currentUrl, resolvedUrl);
                            }
                            
                            currentUrl = resolvedUrl;
                            continue;
                        }
                    }
                    
                    // 2. БЛОКИРОВКИ
                    if (statusCode == 403 || statusCode == 401 || statusCode == 429) {
                        result.setFinalUrl(currentUrl);
                        result.setStatus(PageStatus.FORBIDDEN.toString());
                        result.setRedirectCount(redirectCount);
                        return result;
                    }
                    
                    // 3. НЕ НАЙДЕНО
                    if (statusCode == 404) {
                        result.setFinalUrl(currentUrl);
                        result.setStatus(PageStatus.NOT_FOUND.toString());
                        result.setRedirectCount(redirectCount);
                        return result;
                    }
                    
                    // 4. УСПЕХ
                    if (statusCode >= 200 && statusCode < 300) {
                        result.setFinalUrl(currentUrl);
                        result.setStatus(PageStatus.SUCCESS.toString());
                        result.setRedirectCount(redirectCount);
                        return result;
                    }
                    
                    // 5. ОСТАЛЬНЫЕ ОШИБКИ
                    result.setFinalUrl(currentUrl);
                    result.setStatus(PageStatus.ERROR.toString());
                    result.setRedirectCount(redirectCount);
                    return result;
                    
                } catch (reactor.core.Exceptions.ReactiveException e) {
                    if (e.getCause() instanceof java.util.concurrent.TimeoutException) {
                        result.setFinalUrl(originalUrl);
                        result.setStatus(PageStatus.TIMEOUT.toString());
                        result.setRedirectCount(0);
                        return result;
                    }
                    throw e;
                }
            }
            
            // Достигнут лимит редиректов
            result.setFinalUrl(currentUrl);
            result.setStatus(PageStatus.MAX_REDIRECTS.toString());
            result.setRedirectCount(redirectCount);
            
        } catch (WebClientResponseException e) {
            if (antiBlockConfig.isLogStrategies()) {
                log.warn("WebClient response error for URL {}: {} - {}", originalUrl, e.getStatusCode(), e.getMessage());
            }
            
            result.setFinalUrl(originalUrl);
            if (e.getStatusCode().is4xxClientError()) {
                if (e.getStatusCode().value() == 404) {
                    result.setStatus(PageStatus.NOT_FOUND.toString());
                } else {
                    result.setStatus(PageStatus.FORBIDDEN.toString());
                }
            } else {
                result.setStatus(PageStatus.ERROR.toString());
            }
            result.setRedirectCount(0);
            
        } catch (reactor.core.Exceptions.ReactiveException e) {
            String errorMessage = e.getMessage() != null ? e.getMessage().toLowerCase() : "";
            
            if (errorMessage.contains("timeout")) {
                result.setFinalUrl(originalUrl);
                result.setStatus(PageStatus.TIMEOUT.toString());
            } else if (errorMessage.contains("unknown host") || errorMessage.contains("unresolved address")) {
                result.setFinalUrl(originalUrl);
                result.setStatus(PageStatus.UNKNOWN_HOST.toString());
            } else {
                result.setFinalUrl(originalUrl);
                result.setStatus(PageStatus.IO_ERROR.toString());
            }
            result.setRedirectCount(0);
            
            if (antiBlockConfig.isLogStrategies()) {
                log.warn("WebClient reactive error for URL {}: {}", originalUrl, e.getMessage());
            }
            
        } catch (Exception e) {
            log.error("WebClient critical error for URL {}: {}", originalUrl, e.getMessage());
            result.setFinalUrl(originalUrl);
            result.setStatus(PageStatus.ERROR.toString());
            result.setRedirectCount(0);
        }
        
        return result;
    }
    
    /**
     * Настройка реалистичных заголовков
     */
    private void setupRealisticHeaders(WebClient.RequestHeadersSpec<?> request) {
        String userAgent = getRandomUserAgent();
        
        request
            .header("User-Agent", userAgent)
            .header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8")
            .header("Accept-Language", "ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7")
            .header("Accept-Encoding", "gzip, deflate, br")
            .header("DNT", "1")
            .header("Connection", "keep-alive")
            .header("Upgrade-Insecure-Requests", "1")
            .header("Sec-Fetch-Dest", "document")
            .header("Sec-Fetch-Mode", "navigate")
            .header("Sec-Fetch-Site", "none")
            .header("Sec-Fetch-User", "?1")
            .header("Cache-Control", "max-age=0")
            .header("Referer", getRandomReferer());
        
        // Chrome-specific headers
        if (userAgent.contains("Chrome")) {
            request
                .header("sec-ch-ua", "\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Google Chrome\";v=\"120\"")
                .header("sec-ch-ua-mobile", "?0")
                .header("sec-ch-ua-platform", "\"Windows\"");
        }
    }
    
    /**
     * Получение случайного User-Agent
     */
    private String getRandomUserAgent() {
        var userAgents = antiBlockConfig.getUserAgents();
        if (userAgents.isEmpty()) {
            String[] fallbackUserAgents = {
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            };
            return fallbackUserAgents[ThreadLocalRandom.current().nextInt(fallbackUserAgents.length)];
        }
        return userAgents.get(ThreadLocalRandom.current().nextInt(userAgents.size()));
    }
    
    /**
     * Получение случайного Referer
     */
    private String getRandomReferer() {
        String[] referers = {
            "https://www.google.com/",
            "https://www.google.ru/",
            "https://yandex.ru/",
            "https://www.bing.com/"
        };
        return referers[ThreadLocalRandom.current().nextInt(referers.length)];
    }
    
    /**
     * Проверка статуса на редирект
     */
    private boolean isRedirectStatus(int statusCode) {
        return statusCode == 301 || statusCode == 302 || statusCode == 303 || 
               statusCode == 307 || statusCode == 308;
    }
    
    /**
     * Разрешение относительных URL
     */
    private String resolveUrl(String baseUrl, String location) {
        if (location.startsWith("http://") || location.startsWith("https://")) {
            return location;
        }
        
        try {
            URI baseUri = URI.create(baseUrl);
            URI resolved = baseUri.resolve(location);
            return resolved.toString();
        } catch (Exception e) {
            log.warn("Error resolving URL: base={}, location={}", baseUrl, location);
            return location;
        }
    }
}